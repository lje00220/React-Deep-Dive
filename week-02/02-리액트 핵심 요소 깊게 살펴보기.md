# 02장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

JSX는 XML과 유사한 내장형 구문이다. JSX는 트랜스파일을 거쳐야 자바스크립트 코드로 변환된다.
**JSX의 목표**: JSX 내부에 트리 구조로 작성 > 트랜스파일 > 자바스크립트가 이해할 수 있는 코드로 변경

### 2.1.1. JSX의 정의

JSX는 4가지 컴포넌트를 기반으로 구성

1. **JSXElement**: JSX의 가장 기본 요소

   - `JSXOpeningElement`: 시작 시 JSXClosingElement와 동일 요소로 같은 단계에 선언되어야 함
   - `JSXClosingElement`: JSXOpeningElement가 종료되었음을 알리는 요소
   - `JSXSelfClosingElement`: 요소가 시작되고, 스스로 종료되는 형태
   - `JSXFragment`: 아무런 요소가 없는 형태

2. **JSXElementName**: JSXElement의 요소 이름으로 쓸 수 있는 것

   - `JSXIdentifier`: JSX 내부에서 사용할 수 있는 식별자로 자바스크립트 식별자 규칙과 동일

     ```javascript
     function Valid1() {
       return <$></$>;
     }
     ```

   - `JSXNameSpacedName`: JSXIdentifier:JSXIdentifier의 조합으로 한 개만 묶을 수 있다.

     ```javascript
     function valid() {
       return <foo:bar></foo:bar>;
     }
     ```

   - `JSXMemberExpression`: JSXIdentifier.JSXIdentifier의 조합으로 여러 개를 묶을 수 있다.

     ```javascript
     function valid() {
       return <foo.bar.baz></foo.bar.baz>;
     }
     ```

3. **JSXAttributes**: JSXElement에 부여할 수 있는 속성(필수값 X)

   - `JSXSpreadAttributes`: 자바스크립트의 전개 연산자와 동일한 역할
   - `JSXAttribute`: 속성을 나타내는 키와 값

     - JSXAttributeName: 속성의 키 값, JSXIdentifier와 JSXNamespacedName 가능
     - JSXAttributeValue: 키에 할당할 수 있는 값, "", '', {AssignmentExpression}, JSXElement, JSXFragment 중 하나를 만족해야 한다.

4. **JSXChildren**: JSXElement의 자식 값

   JSXChild는 JSXChildren을 이루는 기본 단위

   - JSXText: {, <, >, }을 제외한 문자열
   - JSXElement
   - JSXFragment
   - { JSXChildExpression (optional) }

     ```javascript
     export default function App() {
       return <>{() => "foo"}</>;
     }
     ```

5. **JSXStrings**

   HTML에서 사용 가능한 문자열은 JSXStrings에서 사용 가능하다. 자바스크립트와의 차이점은 `\`을 제약 없이 사용할 수 있다는 것이다.

### 2.1.2 JSX 예제

```javascript
const ComponentF = (
  <A required={true}>
    <B text="리액트" />
  </A>
);

// JSXElement: '<A required={true}> <B text="리액트" /> </A>'
// JSXElementName: 'A', 'B'
// JSXAttributes: 'required={true}', 'text="리액트"'
// JSXChildren: '<B text="리액트" />'
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- JSXElement를 첫 번째 인수로 선언해 요소를 정의
- JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨 처리

```javascript
// JSX 코드
const Component = <A required={true}>Hello World</A>;

// 변환 결과
var Component = React.createElement(
  A,
  {
    required: true,
  },
  "Hello World"
);
// React.createElement(JSXElementName, {JSXAttributes}, JSXStrings) 순서로 처리
```

## 2.2 가상 DOM과 리액트 파이버

리액트의 특징 중 하나는 가상 DOM을 운영한다는 것이다.

### 2.2.1 DOM과 브라우저 렌더링 과정

`DOM`: 웹페이지에 대한 인터페이스 (브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.) <br /><br />
DOM과 CSSOM으로 렌더링 트리가 만들어지는 과정
![image](https://web.dev/static/articles/critical-rendering-path/render-tree-construction/image/dom-cssom-are-combined-8de5805b2061e_1920.png?hl=ko)

### 2.2.2 가상 DOM의 탄생 배경

- 브라우저가 웹페이지를 렌더링하는 과정은 복잡하고 많은 비용이 든다.
- 렌더링 완료 후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황을 고려해야 한다.
- 싱글 페이지 애플리케이션에서는 계속해서 요소의 위치를 재계산하기 때문에 DOM을 관리하는 과정에서 비용 부담이 커진다.

  ➡ 가상 DOM의 탄생

  - 웹페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트에서 변경에 대한 준비가 완료됐을 때 실제 DOM에 반영
  - 렌더링 과정을 최소화

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트 파이버를 통해 가상 DOM과 렌더링 과정 최적화

1. **리액트 파이버란?**

   파이버는 파이버 재조정자가 관리 <br>

   `파이버 재조정자`: 가상 DOM과 실제 DOM 사이 변경 사항을 수집하여 변경에 관련된 정보를 가진 파이버를 기준으로 렌더링 요청
   `파이버`: 하나의 작업 단위로 구성

   - 작업을 작은 단위로 쪼개고 우선순위를 매긴다.
   - 작업을 일시 중지할 수 있다.
   - 이전 작업을 폐기할 수 있다.
   - 모든 과정이 비동기로 일어난다.
   - 리액트 요소와 다르게 렌더링이 발생할 때 가급적 재사용된다.

   **파이버의 주요 속성**

   - tag: 파이버는 하나의 element에 하나가 생성되는 1:1 관계로 tag에 매칭된 정보가 들어있다.
   - stateNode: 파이버 자체에 대한 참조 정보를 가지고 있다.
   - child, sibling, return: 파이버 간 관계 개념을 나타낸다. return은 부모 파이버를 의미하며, 오직 하나의 child만 존재한다.
   - index: 형제들 사이에서 자신의 위치
   - pendingProps: 아직 작업을 처리하지 못한 props
   - memoizedProps: 렌더링이 완료된 후 pendingProps는 memoizedProps에 저장해 관리한다.
   - updateQueue: 필요한 작업을 담아두는 큐
   - memoizedState: 함수 컴포넌트의 훅 목록 저장
   - alternate: 반대편 트리 파이버

2. **리액트 파이버 트리**

파이버 트리는 현재 모습을 담은 파이버 트리와 작업 중인 상태를 나타내는 workInProgress 트리, 총 2개이다. <br>
리액트는 `더블 버퍼링`을 통해 파이버의 작업이 끝나면 포인터만 변경하여 workInProgress 트리를 현재 트리로 바꾼다. <br>
![image](https://www.velotio.com/engineering-blog/react-fiber-algorithm)

3. **파이버의 작업 순서**

   1. beginWork() 함수를 통해 파이버 작업을 수행한다. 더 이상 자식이 없는 파이버를 만날 때까지 트리를 만든다.
   2. beginWork() 작업이 끝나면 completeWork() 함수를 실행해 파이버 작업을 완료한다.
   3. 형제가 있다면 형제로 넘어간다.
   4. 작업이 모두 끝나면 return으로 돌아가 작업 완료를 알린다.
   5. 이후 업데이트가 발생하면, workInProgress 트리를 빌드하고 작업이 완료되면 이를 current 트리로 바꾼다. (비동기식)
      → 파이버가 이미 존재하므로 기존 파이버에서 업데이트된 props만 받아 처리한다.

### 2.2.4 파이버와 가상 DOM

> 가상 DOM에서 파이버가 작업을 하고 최종 결과물만 실제 브라우저 DOM에 적용된다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 2.3.1 클래스 컴포넌트

클래스를 선언하고 만들고 싶은 컴포넌트를 `extends`하는 방식으로 extends 구문에는 React.Component와 React.PureComponent를 넣을 수 있다.

```javascript
import React from 'react'

// props 타입 선언
interface SampleProps {
  required?: boolean // '?': 선택적 프로퍼티(반드시 제공할 필요 X) => <SampleComponent text="Hello" />는 required를 생략한 경우
  text: string
}

// state 타입 선언
interface SampleState {
  count: number
  isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
// React 컴포넌트로 React.Component를 상속
// React.Component를 상속해야 React의 기본 컴포넌트 기능을 사용할 수 있다.

class SampleComponent extends React.Component<SampleProps, SampleState> {
  // constructor에서 props를 넘겨주고, state의 기본값을 설정한다.
  private constructor(props: SampleProps) {
    super(props) // 부모 클래스인 React.Component의 생성자를 호출 -> props를 부모 클래스에 전달
    this.state = { // state의 초기값 설정
      count: 0,
      isLimited: false,
    }
  }

  // render 내부에서 쓰일 함수 선언
  private handleClick = () => {
    const newValue = this.state.count + 1
    this.setState({ count: newValue, isLimited: newValue >= 10 }) // state를 업데이트하기 위한 함수
    // count가 10 이상이 되면 disabled=false가 되어 버튼 비활성화
  }

  // render에서 이 컴포넌트가 렌더링할 내용을 정의한다. (컴포넌트가 화면에 어떻게 그려질지 정의)
  public render() {
    // props와 state 값을 this, 즉 해당 클래스에서 꺼낸다.
    const {
      props: { required, text },
      state: { count, isLimited },
    } = this

    // return을 통해 렌더링 내용 반환
    return (
      <h2>
        Sample Component
        <div>{required ? '필수' : '필수아님'}</div>
        <div>문자: {text}</div>
        <div>count: {count}</div>
        <button onClick={this.handleClick} disabled={isLimited}>
          증가
        </button>
      </h2>
    )
  }
}
```

- constructor(): 컴포넌트 내부에 있다면 컴포넌트가 초기화되는 시점에 호출 / 컴포넌트의 state를 초기화
- super(props): props를 초기화, 부모 클래스의 기능 상속
- props: 컴포넌트에 특정 속성을 전달하는 용도 / 컴포넌트가 외부에서 받을 수 있는 데이터
- state: 클래스 컴포넌트 내부에서 관리하는 값 (항상 객체)
- 메서드: 렌더링 함수 내부에서 사용되는 함수

  - constructor에서 this 바인드를 하는 방법: 일반적인 함수로 메서드를 만들면 this가 undefined로 나오는 현상이 있기 때문
    → 생선된 함수에 bind를 활용해 강제로 this를 바인딩
  - 화살표 함수를 쓰는 방법: 작성 시점에 this가 상위 스코프로 결정되는 화살표 함수를 쓰면 굳이 바인딩을 하지 않아도 된다.
  - 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법: 메서드 내부에 새롭게 함수를 만들어 전달, 최적화에 어려워서 지양됨

    ```javascript
    <button onClick={() => this.handleClick()}증가</button>
    ```

1. **클래스 컴포넌트의 생명주기 메서드**

생명주기 메서드가 실행되는 시점은 마운트, 업데이트, 언마운트로 나눌 수 있다.

- render()

  - 리액트 클래스 컴포넌트의 필수 값
  - 컴포넌트가 UI를 렌더링하기 위해 사용
  - 마운트와 업데이트 과정에서 발생
  - 부수 효과가 없어야 함 -> 내부에서 this.setState를 호출해서는 안된다.

- componentDidMount()

  - 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
  - this.setState()로 state 값 변경 가능
  - 성능 문제를 일으킬 수 있어서 state를 다루는 것은 생성자에서 하는 것이 좋다.

- componentDidUpdate()

  - 컴포넌트 업데이트가 일어난 이후 즉시 실행
  - state나 props의 변화에 따라 DOM을 업데이트할 때 쓰인다.

- componentWillUnmount()

  - 언마운트나 더 이상 사용되지 않기 직전에 호출
  - this.setState를 호출할 수 없다.
  - 이벤트를 지우거나, API 호출을 취소하거나, 타이머를 지우는 등 작업에 유용하다.

- shouldComponentUpdate()

  -
