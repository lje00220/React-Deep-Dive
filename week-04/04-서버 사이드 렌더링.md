# 04장 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

서버 사이드 렌더링 vs 싱글 페이지 애플리케이션

1. **싱글 페이지 애플리케이션이란?**

`싱글 페이지 애플리케이션(SPA)`: 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식

→ 최초에 데이터를 모두 불러온 후 페이지를 다시 로드하지 않고 동적으로 콘텐츠를 업데이트

- 최초에 로딩해야 하는 자바스크립트 리소스가 커짐
- 이후 받아올 리소스가 적어 사용자에게 훌륭한 UI/UX를 제공한다.

[Google 지도](https://www.google.com/maps/?hl=ko)

> 최초에 서버에서 최소한의 데이터를 불러온 후 이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으로 작동

2. **전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교**

`전통적인 방식`: 페이지 전환 시 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱

[Naver](https://www.naver.com)

3. **싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장**

자바스크립트의 역할이 커지면서 브라우저 내부에서 작동하는 자바스크립트만 잘 작성하면 되는 싱글 페이지 렌더링 방식이 유행하게 되었다. <br>
또한, 이로 인해 JAM 스택이 등장하면서 서버 확장성 문제에서 더 자유로워질 수 있었다.

4. **새로운 패러다임의 웹서비스를 향한 요구**

자바스크립트에서 처리해야 하는 코드가 증가하면서 웹페이지를 불러오는 데 필요한 시간이 더욱 길어졌다.

### 4.1.2 서버 사이드 렌더링이란?

최초에 사용자에게 보여줄 페이지를 **서버**에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식

- 싱글 페이지 어플리케이션 -> 자바스크립트 번들 (사용자 기기의 성능에 따라 좌우)
- 서버 사이드 -> 서버 (비교적 안정적)

1. **서버 사이드 렌더링의 장점**

- 최초 페이지 진입이 비교적 빠르다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
- 누적 레이아웃 이동이 적다.
- 사용자의 디바이스 성능에 비교적 자유롭다.
- 보안에 좀 더 안전하다.

2. **단점**

- 소스코드를 작성할 때 항상 서버를 고려해야 한다.
- 적절한 서버가 구축돼 있어야 한다.
- 서비스 지연에 따른 문제

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

1. **서버 사이드 렌더링 역시 만능이 아니다**

웹페이지를 잘못 설계할 경우 오히려 서버와 클라이언트 2가지를 모두 관리하는 역효과만 나타날 수 있다.

2. **싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션**

- 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.
- 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션보다 느리다.

3. **현대의 서버 사이드 렌더링**

최초 진입 시 서버 사이드 렌더링 + 이후 싱글 페이지 애플리케이션처럼 작동

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

### 4.2.1 renderToString

인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수, 최초 페이지를 HTML로 먼저 렌더링

```javascript
  const html = renderToString(reactNode, options?
  // HTML로 렌더링 할 리액트 노드, 서버 렌더링을 위한 객체

  import { renderToString } from 'react-dom/server';

  // 라우트 핸들러 구문은 백엔드 프레임워크에 따라 다릅니다
  app.use('/', (request, response) => {
    const html = renderToString(<App />);
    response.send(html);
  });
```

> 클라이언트에서 react-dom/server를 가져오면 불필요하게 번들 크기가 커지므로 지양해야 함

### 4.2.2 renderToStaticMarkup

리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
→ HTML의 크기를 조금 줄일 수 있다. (정적 HTML 생성)

```javascript
import { renderToStaticMarkup } from "react-dom/server";

const html = renderToStaticMarkup(<Page />);
```

> 리액트의 이벤트 리스너가 필요 없는 순수한 HTML을 만들 때 사용

### 4.2.3 renderToNodeStream

- 브라우저에서 사용할 수 없으며, Node.js 환경에 의존
- 결과물이 ReadableStream이므로 string을 얻기 위해 추가적인 처리가 필요
- 스트림을 사용하여 큰 크기의 데이터를 분리해 순차적으로 처리할 수 있다.

### 4.2.4 renderToStaticNodeStream

순수 HTML 결과물이 필요할 때 사용하는 renderToNodeStream과 유사한 메서드

### 4.2.5 hydrate

renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 이벤트 핸들러를 붙이는 역할
